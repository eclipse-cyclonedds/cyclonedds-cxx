#include "org/eclipse/cyclonedds/topic/hash.hpp"

size_t u::write_struct(void *data, size_t position) const
{
  size_t _al0 = (4 - (position&0x3))&0x3;  //alignment
  memset(static_cast<char*>(data)+position,0x0,_al0);  //setting alignment bytes to 0x0
  position += _al0;  //moving position indicator
  *reinterpret_cast<int32_t*>(static_cast<char*>(data)+position) = _d();  //writing bytes for member: _d()
  position += 4;  //moving position indicator
  switch (_d())
  {
    case 0:
    case 1:
    {
      *reinterpret_cast<uint8_t*>(static_cast<char*>(data)+position) = o();  //writing bytes for member: o()
      position += 1;  //moving position indicator
    }
    break;
    case 2:
    case 3:
    {
      *reinterpret_cast<int32_t*>(static_cast<char*>(data)+position) = l();  //writing bytes for member: l()
      position += 4;  //moving position indicator
    }
    break;
    case 4:
    case 5:
    {
      uint32_t _se2 = static_cast<uint32_t>(str().size()+1);  //number of entries in the sequence
      *reinterpret_cast<uint32_t*>(static_cast<char*>(data) + position) = _se2;  //writing entries for member: str()
      position += 4;  //moving position indicator
      memcpy(static_cast<char*>(data)+position,str().data(),_se2*1); //writing bytes for member: str()
      position += _se2;  //entries of sequence
    }
    break;
    default:
    {
      *reinterpret_cast<float*>(static_cast<char*>(data)+position) = f();  //writing bytes for member: f()
      position += 4;  //moving position indicator
    }
    break;
  }
  return position;
}

size_t ss::write_struct(void *data, size_t position) const
{
  *reinterpret_cast<uint8_t*>(static_cast<char*>(data)+position) = o();  //writing bytes for member: o()
  position += 1;  //moving position indicator
  position = u().write_struct(data, position);
  size_t _al0 = (4 - (position&0x3))&0x3;  //alignment
  memset(static_cast<char*>(data)+position,0x0,_al0);  //setting alignment bytes to 0x0
  position += _al0;  //moving position indicator
  *reinterpret_cast<int32_t*>(static_cast<char*>(data)+position) = l();  //writing bytes for member: l()
  position += 4;  //moving position indicator
  return position;
}

size_t u::write_size(size_t position) const
{
  position += (4 - (position&0x3))&0x3;  //alignment
  position += 4;  //bytes for member: _d()
  switch (_d())
  {
    case 0:
    case 1:
    {
      position += 1;  //bytes for member: o()
    }
    break;
    case 2:
    case 3:
    {
      position += 4;  //bytes for member: l()
    }
    break;
    case 4:
    case 5:
    {
      uint32_t _se2 = static_cast<uint32_t>(str().size()+1);  //number of entries in the sequence
      position += 4;  //bytes for sequence entries
      position += _se2;  //entries of sequence
    }
    break;
    default:
    {
      position += 4;  //bytes for member: f()
    }
    break;
  }
  return position;
}

size_t ss::write_size(size_t position) const
{
  position += 1;  //bytes for member: o()
  position = u().write_size(position);
  position += (4 - (position&0x3))&0x3;  //alignment
  position += 4;  //bytes for member: l()
  return position;
}

size_t u::max_size(size_t position) const
{
  (void)position;
  return UINT_MAX;
}

size_t ss::max_size(size_t position) const
{
  if (position != UINT_MAX)   position += 1;  //bytes for member: o()
  if (position != UINT_MAX)   position = u().max_size(position);
  if (position != UINT_MAX)   position += (4 - (position&0x3))&0x3;  //alignment
  if (position != UINT_MAX)   position += 4;  //bytes for member: l()
  return position;
}

size_t u::key_size(size_t position) const
{
  return position;
}

size_t ss::key_size(size_t position) const
{
  position = u().write_size(position);
  position += (4 - (position&0x3))&0x3;  //alignment
  position += 4;  //bytes for member: l()
  return position;
}

size_t u::key_max_size(size_t position) const
{
  return position;
}

size_t ss::key_max_size(size_t position) const
{
  if (position != UINT_MAX)   position = u().max_size(position);
  if (position != UINT_MAX)   position += (4 - (position&0x3))&0x3;  //alignment
  if (position != UINT_MAX)   position += 4;  //bytes for member: l()
  return position;
}

size_t u::key_write(void *data, size_t position) const
{
  (void)data;
  return position;
}

bool u::key(ddsi_keyhash_t &hash) const
{
  size_t sz = key_size(0);
  size_t padding = 16 - sz%16;
  if (sz != 0 && padding == 16) padding = 0;
  std::vector<unsigned char> buffer(sz+padding);
  memset(buffer.data()+sz,0x0,padding);
  key_write(buffer.data(),0);
  static bool (*fptr)(const std::vector<unsigned char>&, ddsi_keyhash_t &) = NULL;
  if (fptr == NULL)
  {
    if (key_max_size(0) <= 16)
    {
      //bind to unmodified function which just copies buffer into the keyhash
      fptr = &org::eclipse::cyclonedds::topic::simple_key;
    }
    else
    {
      //bind to MD5 hash function
      fptr = &org::eclipse::cyclonedds::topic::complex_key;
    }
  }
  return (*fptr)(buffer,hash);
}

size_t ss::key_write(void *data, size_t position) const
{
  (void)data;
  position = u().write_struct(data, position);
  size_t _al0 = (4 - (position&0x3))&0x3;  //alignment
  memset(static_cast<char*>(data)+position,0x0,_al0);  //setting alignment bytes to 0x0
  position += _al0;  //moving position indicator
  *reinterpret_cast<int32_t*>(static_cast<char*>(data)+position) = l();  //writing bytes for member: l()
  position += 4;  //moving position indicator
  return position;
}

bool ss::key(ddsi_keyhash_t &hash) const
{
  size_t sz = key_size(0);
  size_t padding = 16 - sz%16;
  if (sz != 0 && padding == 16) padding = 0;
  std::vector<unsigned char> buffer(sz+padding);
  memset(buffer.data()+sz,0x0,padding);
  key_write(buffer.data(),0);
  static bool (*fptr)(const std::vector<unsigned char>&, ddsi_keyhash_t &) = NULL;
  if (fptr == NULL)
  {
    if (key_max_size(0) <= 16)
    {
      //bind to unmodified function which just copies buffer into the keyhash
      fptr = &org::eclipse::cyclonedds::topic::simple_key;
    }
    else
    {
      //bind to MD5 hash function
      fptr = &org::eclipse::cyclonedds::topic::complex_key;
    }
  }
  return (*fptr)(buffer,hash);
}

size_t u::key_read(const void *data, size_t position)
{
  (void)data;
  clear();
  return position;
}

size_t ss::key_read(const void *data, size_t position)
{
  (void)data;
  position = u().read_struct(data, position);
  position += (4 - (position&0x3))&0x3;  //alignment
  l() = *reinterpret_cast<const int32_t*>(static_cast<const char*>(data)+position);  //reading bytes for member: l()
  position += 4;  //moving position indicator
  return position;
}

size_t u::read_struct(const void *data, size_t position)
{
  clear();
  position += (4 - (position&0x3))&0x3;  //alignment
  _d() = *reinterpret_cast<const int32_t*>(static_cast<const char*>(data)+position);  //reading bytes for member: _d()
  position += 4;  //moving position indicator
  switch (_d())
  {
    case 0:
    case 1:
    {
      o() = *reinterpret_cast<const uint8_t*>(static_cast<const char*>(data)+position);  //reading bytes for member: o()
      position += 1;  //moving position indicator
    }
    break;
    case 2:
    case 3:
    {
      l() = *reinterpret_cast<const int32_t*>(static_cast<const char*>(data)+position);  //reading bytes for member: l()
      position += 4;  //moving position indicator
    }
    break;
    case 4:
    case 5:
    {
      uint32_t _se2 = *reinterpret_cast<const uint32_t*>(static_cast<const char*>(data)+position);  //number of entries in the sequence
      position += 4;  //moving position indicator
      str().assign(static_cast<const char*>(data)+position,static_cast<const char*>(data)+position+_se2-1); //reading bytes for member: str()
      position += _se2;  //entries of sequence
    }
    break;
    default:
    {
      f() = *reinterpret_cast<const float*>(static_cast<const char*>(data)+position);  //reading bytes for member: f()
      position += 4;  //moving position indicator
    }
    break;
  }
  return position;
}

size_t ss::read_struct(const void *data, size_t position)
{
  o() = *reinterpret_cast<const uint8_t*>(static_cast<const char*>(data)+position);  //reading bytes for member: o()
  position += 1;  //moving position indicator
  position = u().read_struct(data, position);
  position += (4 - (position&0x3))&0x3;  //alignment
  l() = *reinterpret_cast<const int32_t*>(static_cast<const char*>(data)+position);  //reading bytes for member: l()
  position += 4;  //moving position indicator
  return position;
}

