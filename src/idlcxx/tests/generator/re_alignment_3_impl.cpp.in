#include "org/eclipse/cyclonedds/topic/hash.hpp"

size_t s::write_struct(void *data, size_t position) const
{
  for (size_t _i1 = 0; _i1 < 3; _i1++)  {
    size_t _al1 = (4 - (position&0x3))&0x3;  //alignment
    memset(static_cast<char*>(data)+position,0x0,_al1);  //setting alignment bytes to 0x0
    position += _al1;  //moving position indicator
    uint32_t _se1 = static_cast<uint32_t>(string_arr()[_i1].size()+1);  //number of entries in the sequence
    *reinterpret_cast<uint32_t*>(static_cast<char*>(data) + position) = _se1;  //writing entries for member: string_arr()[_i1]
    position += 4;  //moving position indicator
    memcpy(static_cast<char*>(data)+position,string_arr()[_i1].data(),_se1*1); //writing bytes for member: string_arr()[_i1]
    position += _se1;  //entries of sequence
  }
  size_t _al0 = (4 - (position&0x3))&0x3;  //alignment
  memset(static_cast<char*>(data)+position,0x0,_al0);  //setting alignment bytes to 0x0
  position += _al0;  //moving position indicator
  uint32_t _se0 = static_cast<uint32_t>(string_seq().size());  //number of entries in the sequence
  *reinterpret_cast<uint32_t*>(static_cast<char*>(data) + position) = _se0;  //writing entries for member: string_seq()
  position += 4;  //moving position indicator
  for (size_t _i1 = 0; _i1 < _se0; _i1++) {
    size_t _al1 = (4 - (position&0x3))&0x3;  //alignment
    memset(static_cast<char*>(data)+position,0x0,_al1);  //setting alignment bytes to 0x0
    position += _al1;  //moving position indicator
    uint32_t _se1 = static_cast<uint32_t>(string_seq()[_i1].size()+1);  //number of entries in the sequence
    *reinterpret_cast<uint32_t*>(static_cast<char*>(data) + position) = _se1;  //writing entries for member: string_seq()[_i1]
    position += 4;  //moving position indicator
    memcpy(static_cast<char*>(data)+position,string_seq()[_i1].data(),_se1*1); //writing bytes for member: string_seq()[_i1]
    position += _se1;  //entries of sequence
  }
  _al0 = (4 - (position&0x3))&0x3;  //alignment
  memset(static_cast<char*>(data)+position,0x0,_al0);  //setting alignment bytes to 0x0
  position += _al0;  //moving position indicator
  _se0 = static_cast<uint32_t>(long_seq().size());  //number of entries in the sequence
  *reinterpret_cast<uint32_t*>(static_cast<char*>(data) + position) = _se0;  //writing entries for member: long_seq()
  position += 4;  //moving position indicator
  if (0 < long_seq().size()) memcpy(static_cast<char*>(data)+position,long_seq().data(),_se0*4); //writing bytes for member: long_seq()
  position += _se0*4;  //entries of sequence
  return position;
}

size_t s::write_size(size_t position) const
{
  for (size_t _i1 = 0; _i1 < 3; _i1++)  {
    position += (4 - (position&0x3))&0x3;  //alignment
    uint32_t _se1 = static_cast<uint32_t>(string_arr()[_i1].size()+1);  //number of entries in the sequence
    position += 4;  //bytes for sequence entries
    position += _se1;  //entries of sequence
  }
  position += (4 - (position&0x3))&0x3;  //alignment
  uint32_t _se0 = static_cast<uint32_t>(string_seq().size());  //number of entries in the sequence
  position += 4;  //bytes for sequence entries
  for (size_t _i1 = 0; _i1 < _se0; _i1++) {
    position += (4 - (position&0x3))&0x3;  //alignment
    uint32_t _se1 = static_cast<uint32_t>(string_seq()[_i1].size()+1);  //number of entries in the sequence
    position += 4;  //bytes for sequence entries
    position += _se1;  //entries of sequence
  }
  position += (4 - (position&0x3))&0x3;  //alignment
  _se0 = static_cast<uint32_t>(long_seq().size());  //number of entries in the sequence
  position += 4;  //bytes for sequence entries
  position += _se0*4;  //entries of sequence
  return position;
}

size_t s::max_size(size_t position) const
{
  (void)position;
  return UINT_MAX;
}

size_t s::key_size(size_t position) const
{
  return position;
}

size_t s::key_max_size(size_t position) const
{
  return position;
}

size_t s::key_write(void *data, size_t position) const
{
  (void)data;
  return position;
}

bool s::key(ddsi_keyhash_t &hash) const
{
  size_t sz = key_size(0);
  size_t padding = 16 - sz%16;
  if (sz != 0 && padding == 16) padding = 0;
  std::vector<unsigned char> buffer(sz+padding);
  memset(buffer.data()+sz,0x0,padding);
  key_write(buffer.data(),0);
  static bool (*fptr)(const std::vector<unsigned char>&, ddsi_keyhash_t &) = NULL;
  if (fptr == NULL)
  {
    if (key_max_size(0) <= 16)
    {
      //bind to unmodified function which just copies buffer into the keyhash
      fptr = &org::eclipse::cyclonedds::topic::simple_key;
    }
    else
    {
      //bind to MD5 hash function
      fptr = &org::eclipse::cyclonedds::topic::complex_key;
    }
  }
  return (*fptr)(buffer,hash);
}

size_t s::key_read(const void *data, size_t position)
{
  (void)data;
  return position;
}

size_t s::read_struct(const void *data, size_t position)
{
  for (size_t _i1 = 0; _i1 < 3; _i1++)  {
    position += (4 - (position&0x3))&0x3;  //alignment
    uint32_t _se1 = *reinterpret_cast<const uint32_t*>(static_cast<const char*>(data)+position);  //number of entries in the sequence
    position += 4;  //moving position indicator
    string_arr()[_i1].assign(static_cast<const char*>(data)+position,static_cast<const char*>(data)+position+_se1-1); //reading bytes for member: string_arr()[_i1]
    position += _se1;  //entries of sequence
  }
  position += (4 - (position&0x3))&0x3;  //alignment
  uint32_t _se0 = *reinterpret_cast<const uint32_t*>(static_cast<const char*>(data)+position);  //number of entries in the sequence
  position += 4;  //moving position indicator
  string_seq().resize(_se0);
  for (size_t _i1 = 0; _i1 < _se0; _i1++) {
    position += (4 - (position&0x3))&0x3;  //alignment
    uint32_t _se1 = *reinterpret_cast<const uint32_t*>(static_cast<const char*>(data)+position);  //number of entries in the sequence
    position += 4;  //moving position indicator
    string_seq()[_i1].assign(static_cast<const char*>(data)+position,static_cast<const char*>(data)+position+_se1-1); //reading bytes for member: string_seq()[_i1]
    position += _se1;  //entries of sequence
  }
  position += (4 - (position&0x3))&0x3;  //alignment
  _se0 = *reinterpret_cast<const uint32_t*>(static_cast<const char*>(data)+position);  //number of entries in the sequence
  position += 4;  //moving position indicator
  long_seq().assign(reinterpret_cast<const int32_t*>(static_cast<const char*>(data)+position),reinterpret_cast<const int32_t*>(static_cast<const char*>(data)+position)+_se0); //reading bytes for member: long_seq()
  position += _se0*4;  //entries of sequence
  return position;
}

